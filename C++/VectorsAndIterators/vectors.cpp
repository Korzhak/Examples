#include <iostream>
#include <vector>

using namespace std;


int main() {
    // Вектор - автоматизований динамічний масив, який сам слідкує за
    // виділенням пам'яті, за звільнення пам'яті і має методи для
    // спрощеної роботи з ним
    vector<double> myVec; // не потрібно вказувати розмір масива, він має свою ємність
                          // і ми можемо додавати без жодних проблем елементи в кінець

    // Робота з векторами відбувається подібно до роботи з динамічними масивами:
    vector<int> vector_of_integers = {1, 2, 4, 5, 6,7, 8};

    for (auto elem : vector_of_integers) {
        cout << elem << endl;
    }

    // Для вектора не потрібно розраховувати окремо довжину його масиву
    for (int i=0; i<vector_of_integers.size(); i++) {
        cout << vector_of_integers[i] << endl;
    }
    
    // Але в нього існують деякі нові методи для роботи з комірками
    vector_of_integers.push_back(10); // Додавання нового елемента в кінець масиву
    vector_of_integers.pop_back(); // видалення останнього елемента

    // Замість квадратних дужок у нас є метод .at(), який ніколи не дозволить
    // нам вийти за межі нашого динамічного масиву
    for (int i = 0; i < vector_of_integers.size(); i++)
        cout << vector_of_integers.at(i) << endl;

    // Якщо ми спробуємо вийти за межі вектора, в нього є власне виключення
    // яке ми можемо відловити в блоці try-catch (std::out_of_range)


    // Вектор крім свого розміру має ще метод ємності, який показує, скільки елементів
    // в нього може влізти
    cout << vector_of_integers.size() << " <- Кількість елементів | Ємність вектора ->" << vector_of_integers.capacity();
    // [1][2][3][4][5][6][][][][][][] <- н-д, у нашому масиві є 6 елементів
    // ^                ^           ^
    //                size       capacity
    // Поки ємність масиву не зайнята, ми зможемо в нього додавати нові елементи
    // в противному випадку під наш вектор автоматично виділиться нова пам'ять
    // і ми зможемо туди всунути більше елементів

    // Якщо ми знаємо точну кількість елементів, скільки нам потрібно,
    // ми можемо самостійно задати ємність вектора
    vector_of_integers.reserve(20);

    cout << "New capacity: " <<  vector_of_integers.capacity() << endl;

    // Якщо ви вже використали під свої потреби всі комірки і в вас
    // залишились зайві, ви можете використати метод shrink_to_fit,
    // це зменшить ємність вашого масива до кількості елементів в ньому
    vector_of_integers.shrink_to_fit();

    vector_of_integers.empty(); // перевірка, чи вектор пустий

    // для додавання чи видалення елементів з масиву є методи insert та erease

    // очистити весь вектор ми можемо за допомогою метода .clear();
    vector_of_integers.clear();

    return 0;
}